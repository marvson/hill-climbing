from typing import Any, Generator, List, Tuple
from random import shuffle, seed
from math import sqrt


def euclidian_distance(x: Tuple[int, int], y: Tuple[int, int]) -> float:
    """Returns the Euclidian distance between two 2D points

    Parameters
    ----------
    x : Tuple[int, int]
    y : Tuple[int, int]

    Returns
    -------
    float
        The Euclidian distance between x and y
    """
    (x1, x2), (y1, y2) = x, y
    return sqrt(sum([(x1 - y1) ** 2, (x2 - y2) ** 2]))


def evaluate(solution: List[Tuple[int, float, float]]) -> float:
    """Evaluates a travelling salesman solution

    Given a list of cities, the evaluation is the sum of the distances from each
    city to the next from the first city to the last, and back to the first. Since
    we want to minimize the distance, we return the negative of it.

    Parameters
    ----------
    solution : List[Tuple[int, float, float]]
        A solution to the travelling salesman problem

    Returns
    -------
    float
        The inverse of the total distante of the trajectory
    """
    cities = [(x, y) for (_, x, y) in solution]  # unpack x and y

    total_distance = euclidian_distance(cities[-1], cities[0])  # last to first
    for i in range(len(solution) - 1):  # each city to the next one
        total_distance += euclidian_distance(cities[i], cities[i + 1])
    return -total_distance


def all_possible_swaps(solution: List[Any]) -> None:
    """Generate all solutions that come from a swap between two points' positions

    For each pair of different elements from the solution, it swaps the two points
    and yields a new solution.

    Parameters
    ----------
    solution : List[Any]
        A solution to the travelling salesman problem, not the best one tho.

    Yields
    -------
    Iterator[List[Any]]
        A new solution generated by swapping two consecutive points
    """
    for i in range(len(solution)):
        for j in range(i, len(solution)):
            if i != j:  # it would be dumb swap it with itself
                new_solution = solution[:]  # copy list
                new_solution[i], new_solution[j] = solution[j], solution[i]  # swap
                yield new_solution


def consecutive_swaps(solution: List[Any]) -> None:
    """Generator function that swap all consecutive elements of a solution

    For each pair of consecutive elements, this function generates a new solution
    with these two elements swapped.

    Parameters
    ----------
    solution : List[Any]
        A solution to the travelling salesman problem, not the best one tho.

    Yields
    -------
    Iterator[List[Any]]
        A new solution generated by swapping two consecutive points
    """
    for i in range(len(solution) - 1):
        new_solution = solution[:]
        new_solution[i], new_solution[i + 1] = solution[i + 1], solution[i]
        yield new_solution


def n_shuffle(n: int) -> Generator[List[Any], List[Any], None]:
    """Creates a generator function that yields a randomly shuffled list n times

    Parameters
    ----------
    n : int
        Number of times that the generator will shuffle the list and yield it
        before terminating.

    Yields
    -------
    Generator[List[Any], List[Any], None]
        A generator function that receives a list and yields a shuffled list
        from the provided one n times
    """

    def gen_shuffle(solution: List[Any]) -> List[Any]:
        for _ in range(n):
            new_solution = solution[:]
            shuffle(new_solution)  # randomly changes the place of every element
            yield new_solution

    seed()  # Seeding the RNG
    return gen_shuffle
